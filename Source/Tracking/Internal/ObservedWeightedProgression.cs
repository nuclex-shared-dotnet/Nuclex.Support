#region CPL License
/*
Nuclex Framework
Copyright (C) 2002-2008 Nuclex Development Labs

This library is free software; you can redistribute it and/or
modify it under the terms of the IBM Common Public License as
published by the IBM Corporation; either version 1.0 of the
License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
IBM Common Public License for more details.

You should have received a copy of the IBM Common Public
License along with this library
*/
#endregion

using System;
using System.Collections.Generic;

namespace Nuclex.Support.Tracking {

  /// <summary>Progression being observed by another class</summary>
  /// <typeparam name="ProgressionType">
  ///   Type of the progression that is being observed
  /// </typeparam>
  internal class ObservedWeightedProgression<ProgressionType> : IDisposable
    where ProgressionType : Progression {

    /// <summary>Delegate for reporting progress updates</summary>
    public delegate void ReportDelegate();

    /// <summary>Initializes a new observed progression</summary>
    /// <param name="weightedProgression">Weighted progression being observed</param>
    /// <param name="progressUpdateCallback">
    ///   Callback to invoke when the progression's progress changes
    /// </param>
    /// <param name="endedCallback">
    ///   Callback to invoke when the progression has ended
    /// </param>
    internal ObservedWeightedProgression(
      WeightedProgression<ProgressionType> weightedProgression,
      ReportDelegate progressUpdateCallback,
      ReportDelegate endedCallback
    ) {
      this.weightedProgression = weightedProgression;

      // See if this progression has already ended (initial check for performance)
      if(weightedProgression.Progression.Ended) {

        this.progress = 1.0f;

      } else {

        this.endedCallback = endedCallback;
        this.progressUpdateCallback = progressUpdateCallback;

        this.weightedProgression.Progression.AsyncEnded +=
          new EventHandler(asyncEnded);

        // Check whether this progression might have ended before we were able to
        // attach ourselfes to its event. If so, don't bother registering to the
        // other event and (important) set our progress to 1.0 because, since we
        // might not have gotten the 'Ended' event, it might otherwise stay at 0.0
        // even though the progression is in the 'Ended' state.
        if(weightedProgression.Progression.Ended) {
          this.progress = 1.0f;
        } else {
          this.weightedProgression.Progression.AsyncProgressUpdated +=
            new EventHandler<ProgressUpdateEventArgs>(asyncProgressUpdated);
        }

      }
    }

    /// <summary>Immediately releases all resources owned by the object</summary>
    public void Dispose() {
      asyncDisconnectEvents();
    }

    /// <summary>Weighted progression being observed</summary>
    public WeightedProgression<ProgressionType> WeightedProgression {
      get { return this.weightedProgression; }
    }

    /// <summary>Amount of progress this progression has achieved so far</summary>
    public float Progress {
      get { return this.progress; }
    }

    /// <summary>Called when the observed progression has ended</summary>
    /// <param name="sender">Progression that has ended</param>
    /// <param name="e">Not used</param>
    private void asyncEnded(object sender, EventArgs e) {
      ReportDelegate endedCallback = this.endedCallback;
      ReportDelegate progressUpdateCallback = this.progressUpdateCallback;

      asyncDisconnectEvents(); // We don't need those anymore!

      // If the progress hasn't reached 1.0 yet, make a fake report so that even
      // when a progression doesn't report any progress at all, the set or queue
      // owning us will have a percentage of progressions completed.
      //
      // There is the possibility of a race condition here, as a final progress
      // report could have been generated by a thread running the progression
      // that was preempted by this thread. This would cause the progress to
      // jump to 1.0 and then back to whatever the waiting thread will report.
      if(this.progress != 1.0f) {
        this.progress = 1.0f;
        progressUpdateCallback();
      }

      endedCallback();
    }

    /// <summary>Called when the progress of the observed progression changes</summary>
    /// <param name="sender">Progression whose progress has changed</param>
    /// <param name="e">Contains the updated progress</param>
    private void asyncProgressUpdated(object sender, ProgressUpdateEventArgs e) {
      this.progress = e.Progress;
      this.progressUpdateCallback();
    }

    /// <summary>Unsubscribes from all events of the observed progression</summary>
    private void asyncDisconnectEvents() {

      // Make use of the double check locking idiom to avoid the costly lock when
      // the events have already been unsubscribed
      if(this.endedCallback != null) {

        // This is an internal class with special knowledge that there
        // is no risk of deadlock involved, so we don't need a fancy syncRoot!
        lock(this) {
          if(this.endedCallback != null) {
            this.weightedProgression.Progression.AsyncEnded -=
              new EventHandler(asyncEnded);

            this.weightedProgression.Progression.AsyncProgressUpdated -=
              new EventHandler<ProgressUpdateEventArgs>(asyncProgressUpdated);

            this.endedCallback = null;
            this.progressUpdateCallback = null;
          }
        }

      } // endedCallback != null

    }

    /// <summary>The weighted progression that is being observed</summary>
    private WeightedProgression<ProgressionType> weightedProgression;
    /// <summary>Callback to invoke when the progress updates</summary>
    private volatile ReportDelegate progressUpdateCallback;
    /// <summary>Callback to invoke when the progression ends</summary>
    private volatile ReportDelegate endedCallback;
    /// <summary>Progress achieved so far</summary>
    private volatile float progress;
  }

} // namespace Nuclex.Support.Tracking
